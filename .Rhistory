}
curRadius=minRadius+(curSize-minSize)*(maxRadius-minRadius)/(maxSize-minSize)
curRadius
}
#==============================                     ========================
#==============================   BEGIN MAIN PLOT   ========================
#==============================                     ========================
library("plotrix")
library("diagram")
if (printPDF) {
pdf(pdfFileName, width=pdf.x.size, height=pdf.y.size)
}
par(xpd=F, mar=c(6,4,3,0.5))
maxRadius=maxRadius*(numSamples+2)
minRadius=minRadius*(numSamples+2)
title=parFileName
plot(x=1:numSamples, type="n", xlab="", ylab="time (gen)", xlim=c(-0.5, numSamples+1.5), cex.main=0.8,
ylim=c(0, yTimeLimit), main=title, xaxt = 'n', log=logScaleAxis, cex.axis=0.9, , cex.lab=0.9)
axis(side=1, labels=c("Mig Mat",0:(numSamples-1), " \nTimes"), at=0:(numSamples+1), cex.axis=0.8)
mtext("demes", side=1,line=2, cex=0.8)
w <- par("pin")[1]/diff(par("usr")[1:2])
h <- par("pin")[2]/diff(par("usr")[3:4])
aspRatio <- w/h
# aspRatio=yTimeLimit/(numSamples+2)
#--- Plotting population circles according to their current size and sampling time
for (i in 1:numSamples) {
curRadius=interpolRadius(popSizes[i], minPopSize, maxPopSize, minRadius, maxRadius, drawLogPopSize)
#   print(curRadius)
if (i==1) topOfCircle=sampTimes[i]+curRadius*aspRatio else topOfCircle=c(topOfCircle, sampTimes[i]+curRadius*aspRatio)
curColor=popCol
if (sampSizes[i]==0) curColor="white"
if (inbrCoeff[i]==0) {
draw.circle(i, sampTimes[i], radius = curRadius, col=curColor, border=popBorderCol)
} else {
floating.pie(i, sampTimes[i], c(inbrCoeff[i], 1-inbrCoeff[i]), radius = curRadius,
col=c(inbreedColor,curColor), startpos=pi, border=popBorderCol)
}
if (sampTimes[i]>0) {
text(i, sampTimes[i]-curRadius*aspRatio, labels=sampTimes[i], cex=timeProp, col=oldSampColor, pos=1)
}
#Draw a vertical arrow in case of pop growth
curGrowthRate=growthRates[i]
#--- Draw gtrowing or shrinking triangle on top of pop circle to reflect growth type
if (curGrowthRate!=0) {
arLength=0.15
topOfCircle[i]=drawTriangle(curGrowthRate, x=i, y=topOfCircle[i], arLength, aspRatio, color=growthCol)
}
}
#--- Handle first migration matrix .......................
curMigMatNum=0
curvature=0.0075*last.he.time
text(0-migrOffset, 0, labels=0, cex=migMatNameProp, col=migrMatCol)
if (numMigMat) {
curMigMat=migMats[1][[1]]
for (sink in 1:numSamples) {
for (sourc in 1:numSamples) {
if (sink!=sourc & curMigMat[sourc, sink]>0)  {
differ=sourc-sink
curvedarrow(from=c(sourc, 0), to=c(sink,0), curve=curvature*(abs(differ)*0.55^abs(differ)), arr.adj=1,
arr.pos=0.5, arr.type="triangle", arr.col=migrMatCol, lwd=1, lty=curvedArrowLTY,
lcol=migrMatCol, arr.length=arrowLength)
if (plotMigrRates) {
curNm=round(curMigMat[sourc, sink]*popSizes[sourc], digits=2)
if (differ>0) {
text(sink+abs(differ)/2, aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol)
} else {
text(sourc+abs(differ)/2, -aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol)
}
}
}
}
}
}
#---Draw all events on the population tree
lastTime=0
activePops=1:numSamples
numActivePops=numSamples
lastSink=-1
if (numHistEvents) {
for (i in 1:numHistEvents) {
#Extract historical event
he=histEvents[i,]
he.time=he[1]
he.source=he[2]+1 #+1 is due to the use of base 0 for deme number in fsc
he.sink=he[3]+1
he.migr=he[4]
he.resize=he[5]
he.growth=he[6]
if(he.growth==-9999) { #handle transformed keep keyword
he.growth=growthRates[he.sink] #Keep current growth rate
}
he.migrMat=he[7]
if(he.migrMat==-9999) { #handle transformed keep keyword
he.migrMat=curMigMatNum
}
#-- Draw event time
if (i%%2) {
slide=timeOffset
}
else {
slide=-timeOffset
}
#Draw all vertical segments ....................
for (p in 1:length(activePops)) {
#Handle population with older sampling times
if (sampTimes[activePops[p]]>0) {
minTime=max(lastTime, topOfCircle[activePops[p]]);
} else {
minTime=lastTime;
}
if (he.time>sampTimes[activePops[p]] & he.time>topOfCircle[activePops[p]]) {
if (activePops[p]==lastSink | i==1) {
segments(activePops[p], topOfCircle[activePops[p]], activePops[p], he.time)
} else {
segments(activePops[p], minTime, activePops[p], he.time)
}
}
}
#Handle growth rate changes since last event ......................
#Update pop sizes according to current growth rates
if (i>1) {
prev.he=histEvents[i-1,]
branchLength=he.time-lastTime
for (p in 1:length(activePops)) {
curPop=activePops[p]
popSizes[curPop]=popSizes[curPop]*exp(growthRates[curPop]*branchLength);
}
}
#Update growth rate
growthRates[he.sink]=he.growth
lastTime=he.time
#Handle resize of sink pop ........................
popSizes[he.sink]=popSizes[he.sink]*he.resize
curRadius=interpolRadius(popSizes[he.sink], minPopSize, maxPopSize, minRadius, maxRadius, drawLogPopSize)
#     popRadius[he.sink]=curRadius
topOfCircle[he.sink]=he.time+curRadius*aspRatio
draw.circle(he.sink, he.time, radius = curRadius, col=popCol, border=popBorderCol)
#--- Draw growing or shrinking triangle on top of pop circle to reflect growth type
if (he.growth!=0) {
arLength=0.15
topOfCircle[he.sink]=drawTriangle(he.growth, x=he.sink, y=topOfCircle[he.sink], arLength, aspRatio, color=growthCol)
}
#Handle population fusion .........................
if (he.migr>=1 & he.sink!=he.source) { #This is a population fusion
if (numActivePops==numSamples) removedPops=he.source else removedPops=c(removedPops, he.source)
numActivePops=numActivePops-1
activePops=(1:numSamples)[-removedPops]
#Draw connecting arrows from source to sink
fullHeadArrow(he.source, he.time, he.sink, he.time, length=0.15, angle=20)
#Redraw time with the right color
text(numSamples+1+slide, he.time, labels=he.time, cex=timeProp, col=popFusionColor)
} else {
#--- Handle admixture event ........................
if (he.migr>0 & he.migr<1) {
#Draw connecting arrows from source to sink
segments(he.source, he.time, he.sink, he.time, col=admixCol, lty=2)
if (he.sink>he.source) {
fullHeadArrow(he.sink-0.15, he.time, he.sink, he.time, length=0.15, angle=20, color=admixCol)
} else {
fullHeadArrow(he.sink+0.15, he.time, he.sink, he.time, length=0.15, angle=20, color=admixCol)
}
#Redraw time with the right color
text(numSamples+1+slide, he.time, labels=he.time, cex=timeProp, col=admixCol)
}
else text(numSamples+1+slide, he.time, labels=he.time, cex=timeProp, col=timeCol)
}
#--- Handle migmat change  ............................
if (i!=numHistEvents) nextTime=histEvents[i+1,1] else {
nextTime=yTimeLimit
}
time2DrawArrows=(he.time+nextTime)/2
if (he.migrMat!=curMigMatNum) {
if (he.migrMat>-1) {
curMigMat=migMats[he.migrMat+1][[1]]
for (sink in 1:numSamples) {
for (sourc in 1:numSamples) {
if (sink!=sourc & curMigMat[sourc, sink]>0)  {
differ=sourc-sink
curvedarrow(from=c(sourc, time2DrawArrows), to=c(sink, time2DrawArrows), curve=curvature*(abs(differ)*0.55^abs(differ)),
arr.adj=1, arr.pos=0.5, arr.type="triangle", arr.col=migrMatCol, lwd=1, lty=curvedArrowLTY,
lcol=migrMatCol, arr.length=arrowLength)
if (plotMigrRates) {
#Write Nm values
curNm=round(curMigMat[sourc, sink]*popSizes[sourc], digits=2)
if (differ>0) {
text(sink+abs(differ)/2, time2DrawArrows+aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol)
} else {
text(sourc+abs(differ)/2, time2DrawArrows-aspRatio*0.15*abs(differ), labels=curNm, cex=migrRateTextSizeCEX, col=migrMatCol)
}
}
}
}
# curMigMatNum=he.migrMat
}
}
#--- Draw separation between migration matrices numbers on the left
segments(-migMatLineLength/2, he.time, migMatLineLength/2, he.time, lty=3, col=migrMatCol)
}
curMigMatNum=he.migrMat
#Output current valid migration matrix
if (i%%2) {
slide=migrOffset
}
else {
slide=-migrOffset
}
if (he.migrMat>-1) {
migText=he.migrMat
curCex=migMatNameProp
} else {
migText="nomig"
curCex=migMatNameProp/2
slide=slide*2
}
text(0+slide, time2DrawArrows, labels=migText, cex=curCex, col=migrMatCol)
lastSink=he.sink
}
}
#-- Draw last branch
segments(activePops[1],topOfCircle[activePops[1]], activePops[1], yTimeLimit)
#==============================   PLOT LEGENDS IN MARGINS   ========================
#Compute space available in margin
minY.coo=grconvertY(0, from="nic", to="user")
par(xpd=NA)
#--- Draw population size scale with circles of different sizes .................
maxOrder=ceiling(log10(maxPopSize))
minOrder=floor(log10(minPopSize))
popSizeRadius=10^(maxOrder:minOrder)
winWidth=numSamples+2
ypos=3/4*minY.coo
text(x=-winWidth/10*1.2, y=ypos, labels="Pop. \nsizes ", cex=.8, pos=2)
for (i in 1:length(popSizeRadius)) {
curRadius=interpolRadius(popSizeRadius[i], minPopSize, maxPopSize, minRadius, maxRadius, drawLogPopSize)
#   print(curRadius)
if (curRadius>0) {
xpos=-winWidth/10+(i-1)*winWidth/10
draw.circle(xpos, ypos, radius=curRadius, col=popCol, border=popBorderCol)
}
text(xpos, ypos-abs(ypos)*0.1, popSizeRadius[i], cex=0.7, pos=1, col="black")
}
#--- Legend for growing or shrinking populations ...............................
if (isGrowth) {
x=winWidth-1.5*winWidth/10; y=ypos+abs(ypos)*0.2
text(x, y-abs(ypos)*0.1, labels="Populations", cex=0.8)
x=winWidth-2*winWidth/10; y=ypos-abs(ypos)*0.1
drawTriangle(1, x, y, size=0.15, aspRatio, color=growthCol)
text(x, y-abs(ypos)*0.1, labels="growing", pos=NULL, cex=0.7)
x=winWidth-winWidth/10
drawTriangle(-1, x, y, size=0.15, aspRatio, color=growthCol)
text(x, y-abs(ypos)*0.1, labels="shrinking", pos=NULL, cex=0.7)
}
if (printPDF) dev.off()
log10(exp(1))
library(adegenet)
sessionInfo()
?find.clusters
?snapclust
library(riverdist)
?snapclust
sessionInfo()
citation(package="riverdist")
?hzar.doChain.multi
library(hzar)
?hzar.doChain.multi
install.packages("Rcpp")
install.packages("ape")
sessionInfo()
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
library(devtools)
install_github("dmacguigan/PhenoDelimit")
library(devtools)
install_github("dmacguigan/PhenoDelimit")
library(devtools)
install_github("dmacguigan/PhenoDelimit")
library(PhenoDelimit)
?clumpp_prep
?read_CLUMPP_results
?read_clumpp_results
wd="G:/NearLab/WCMW_ddRAD/circos/Eper-Pfla/circos_wholeGenome_altColor_invertedChr"
setwd(wd)
invertList <- read.table("./data/Eper_inverted_chr.txt")
invertList
links <- read.table("./data/link.txt")
links <- read.table("./data/links.txt")
links
karyotype <- read.table("./data/karyotype.Eper.txt")
karyotype
links_split <- split(links, links$V1)
str(links_split)
invertList <- read.table("./data/Eper_inverted_chr.txt")
links <- read.table("./data/links.txt")
karyotype <- read.table("./data/karyotype.Eper.txt")
links_split <- split(links, links$V1)
karyotype
which(karyotype$V2 == "scaffold_13")
which(karyotype$V3 == "scaffold_13")
i = 1
scaff <- invertList$V1[i]
scaff
len <- as.numeric(karyotype$V6[which(karyotype$V3 == scaff)])
len
temp <- links_split$scaff
temp
temp <- links_split[[scaff]]
temp
scaff
temp$V5 <- len - temp$V5
temp$V6 <- len - temp$V6
head(temp)
temp <- links_split[[scaff]]
newStop <- len - temp$V5
newStart <- len - temp$V6
min(newStop-newStart)
max(newStop-newStart)
min(newStop)
min(newStart)
temp <- links_split[[scaff]]
newStop <- len - temp$V2
newStart <- len - temp$V3
temp$V2 <- newStart
temp$V3 <- newStop
min(newStart)
min(newStop)
max(newStop-newStart)
min(newStop-newStart)
for(i in 1:rnow(invertList)){
i = 1
scaff <- invertList$V1[i]
len <- as.numeric(karyotype$V6[which(karyotype$V3 == scaff)])
temp <- links_split[[scaff]]
newStop <- len - temp$V2
newStart <- len - temp$V3
temp$V2 <- newStart
temp$V3 <- newStop
links_split[[scaff]] <- temp
}
for(i in 1:rnows(invertList)){
i = 1
scaff <- invertList$V1[i]
len <- as.numeric(karyotype$V6[which(karyotype$V3 == scaff)])
temp <- links_split[[scaff]]
newStop <- len - temp$V2
newStart <- len - temp$V3
temp$V2 <- newStart
temp$V3 <- newStop
links_split[[scaff]] <- temp
}
for(i in 1:nrow(invertList)){
i = 1
scaff <- invertList$V1[i]
len <- as.numeric(karyotype$V6[which(karyotype$V3 == scaff)])
temp <- links_split[[scaff]]
newStop <- len - temp$V2
newStart <- len - temp$V3
temp$V2 <- newStart
temp$V3 <- newStop
links_split[[scaff]] <- temp
}
test <- unlist(links_split)
str(tet)
str(test)
test
test <- data.frame(matrix(unlist(links_split), nrow=length(links_split), byrow=TRUE))
test <- do.call(rbind.data.frame, links_split)
str(test)
?write.table
write.table(links_inv, "./data/links_inv.txt", quote=FALSE, row.names=FALSE, col.names = FALSE)
links_inv <- do.call(rbind.data.frame, links_split)
write.table(links_inv, "./data/links_inv.txt", quote=FALSE, row.names=FALSE, col.names = FALSE)
wd="G:/NearLab/WCMW_ddRAD/circos/Eper-Pfla/circos_wholeGenome_altColor_invertedChr"
setwd(wd)
invertList <- read.table("./data/Eper_inverted_chr.txt")
links <- read.table("./data/links.txt")
karyotype <- read.table("./data/karyotype.Eper.txt")
links_split <- split(links, links$V1)
invertList
# script to invert chromosomes for circos plot
wd="G:/NearLab/WCMW_ddRAD/circos/Eper-Pfla/circos_wholeGenome_altColor_invertedChr"
setwd(wd)
invertList <- read.table("./data/Eper_inverted_chr.txt")
links <- read.table("./data/links.txt")
karyotype <- read.table("./data/karyotype.Eper.txt")
links_split <- split(links, links$V1)
for(i in 1:nrow(invertList)){
scaff <- invertList$V1[i]
len <- as.numeric(karyotype$V6[which(karyotype$V3 == scaff)])
temp <- links_split[[scaff]]
newStop <- len - temp$V2
newStart <- len - temp$V3
temp$V2 <- newStart
temp$V3 <- newStop
links_split[[scaff]] <- temp
}
links_inv <- do.call(rbind.data.frame, links_split)
write.table(links_inv, "./data/links_inv.txt", quote=FALSE, row.names=FALSE, col.names = FALSE)
# script to invert chromosomes for circos plot
wd="G:/NearLab/WCMW_ddRAD/circos/Eper-Pfla/circos_wholeGenome_altColor_invertedChr"
setwd(wd)
invertList <- read.table("./data/Eper_inverted_chr.txt")
links <- read.table("./data/links.txt")
karyotype <- read.table("./data/karyotype.Eper.txt")
links_split <- split(links, links$V1)
for(i in 1:nrow(invertList)){
scaff <- invertList$V1[i]
len <- as.numeric(karyotype$V6[which(karyotype$V3 == scaff)])
temp <- links_split[[scaff]]
newStop <- len - temp$V2
newStart <- len - temp$V3
temp$V2 <- newStart
temp$V3 <- newStop
links_split[[scaff]] <- temp
}
links_inv <- do.call(rbind.data.frame, links_split)
write.table(links_inv, "./data/links_inv.txt", quote=FALSE, row.names=FALSE, col.names = FALSE)
# script to invert chromosomes for circos plot
wd="G:/NearLab/WCMW_ddRAD/circos/Eper-Pfla/circos_wholeGenome_altColor_invertedChr"
setwd(wd)
invertList <- read.table("./data/Eper_inverted_chr.txt")
links <- read.table("./data/links.txt")
karyotype <- read.table("./data/karyotype.Eper.txt")
links_split <- split(links, links$V1)
for(i in 1:nrow(invertList)){
scaff <- invertList$V1[i]
len <- as.numeric(karyotype$V6[which(karyotype$V3 == scaff)])
temp <- links_split[[scaff]]
newStop <- len - temp$V2
newStart <- len - temp$V3
temp$V2 <- newStart
temp$V3 <- newStop
links_split[[scaff]] <- temp
}
links_inv <- do.call(rbind.data.frame, links_split)
write.table(links_inv, "./data/links_inv.txt", quote=FALSE, row.names=FALSE, col.names = FALSE)
wd="G:/NearLab/WCMW_ddRAD/circos/Eper-Espe/circos_wholeGenome_altColor_invertedChr"
setwd(wd)
invertList <- read.table("./data/Eper_inverted_chr.txt")
links <- read.table("./data/links.txt")
karyotype <- read.table("./data/karyotype.Eper.txt")
links_split <- split(links, links$V1)
for(i in 1:nrow(invertList)){
scaff <- invertList$V1[i]
len <- as.numeric(karyotype$V6[which(karyotype$V3 == scaff)])
temp <- links_split[[scaff]]
newStop <- len - temp$V2
newStart <- len - temp$V3
temp$V2 <- newStart
temp$V3 <- newStop
links_split[[scaff]] <- temp
}
links_inv <- do.call(rbind.data.frame, links_split)
write.table(links_inv, "./data/links_inv.txt", quote=FALSE, row.names=FALSE, col.names = FALSE)
wd="G:/NearLab/WCMW_ddRAD/circos/Eper-Espe/circos_wholeGenome_altColor_invertedChr"
setwd(wd)
invertList <- read.table("./data/Eper_inverted_chr.txt")
links <- read.table("./data/links.txt")
karyotype <- read.table("./data/karyotype.Eper.txt")
links_split <- split(links, links$V1)
for(i in 1:nrow(invertList)){
scaff <- invertList$V1[i]
len <- as.numeric(karyotype$V6[which(karyotype$V3 == scaff)])
temp <- links_split[[scaff]]
newStop <- len - temp$V2
newStart <- len - temp$V3
temp$V2 <- newStart
temp$V3 <- newStop
links_split[[scaff]] <- temp
}
links_inv <- do.call(rbind.data.frame, links_split)
write.table(links_inv, "./data/links_inv.txt", quote=FALSE, row.names=FALSE, col.names = FALSE)
library(RColorBrewer)
library(maps)
library(rgdal)
library(gridExtra)
library(maptools)
library(scales)
library(raster)
library(rgeos)
library(ggplot2)
library(grid)
library(mapplots)
library(dplyr)
library(mapproj)
library(ggmap)
library(ggspatial)
library(sf)
library(ggrepel)
library(rnaturalearth)
library(rnaturalearthdata)
library(rnaturalearthhires)
library(cowplot)
##############################################################################################################################
# specdify the following parameters
HUCs <- c("02030105", "02030103", "02040301", "02040302") # top-level vector of HUCs to match (must be strings, not numeric)
# search for HUCs here: https://water.usgs.gov/wsc/map_index.html
river_name <- "NJCoastalRivers" # river name for files
river_name_plot <- "NJ Coastal Rivers" # river name for plot title
wd <- "H:/USHiddenRivers/" # top level working directory
setwd(wd)
##############################################################################################################################
# READ DATA and PARSE shapefiles
# STATE BORDERS
# read in shape border shapefile
# data from https://github.com/jasperdebie/VisInfo/blob/master/us-state-capitals.csv
state_borders <- readOGR(paste(wd, "/shapefiles/stateBorders/statesp010g.shp", sep=""))
state_borders <- spTransform(state_borders, CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
state_borders_agg <- raster::aggregate(state_borders, dissolve=T)
# STATE BORDERS
# read in shape border shapefile
# data from https://github.com/jasperdebie/VisInfo/blob/master/us-state-capitals.csv
state_borders <- readOGR(paste(wd, "/shapefiles/stateBorders/statesp010g.shp", sep=""))
state_borders <- spTransform(state_borders, CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
state_borders_agg <- raster::aggregate(state_borders, dissolve=T)
